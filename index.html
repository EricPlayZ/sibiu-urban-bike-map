<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <title>Urban Bike Map</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
        <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />
        <style>
            :root {
                --bg: #fff;
                --text: #111;
                --chip: #bbb;
                --shadow: 0 4px 18px #0002;
                --map-dark-bg: #191a1a;
            }
            * {
                box-sizing: border-box;
            }
            body {
                margin: 0;
                font-family: Inter, Arial, sans-serif;
                color: var(--text);
            }
            #map {
                position: absolute;
                inset: 0;
                background-color: var(--map-dark-bg);
            }
            .panel {
                position: absolute;
                top: 16px;
                left: 16px;
                background: var(--bg);
                padding: 10px 14px;
                z-index: 100;
                border-radius: 14px;
                box-shadow: var(--shadow);
                font-size: 15px;
                max-width: 420px;
                max-height: calc(100vh - 32px);
                overflow: auto;
            }
            .panel h3 {
                margin: 0 0 8px 0;
                font-size: 16px;
                font-weight: 700;
                padding-left: 30px; /* Make space for collapse button */
            }
            .group {
                margin: 10px 0;
                padding-left: 10px;
                border-left: 2px solid #eef;
            }
            .row {
                display: flex;
                align-items: center;
                gap: 8px;
                margin: 4px 0;
                cursor: pointer;
                border-radius: 8px;
                padding: 6px;
                transition: background 0.2s;
            }
            .row:hover {
                background: #f6f8ff;
            }
            .chip {
                width: 14px;
                height: 14px;
                border-radius: 50%;
                border: 1px solid var(--chip);
                background: #eee;
                box-shadow: 0 1px 2px #0001;
            }
            .indent {
                margin-left: 22px;
            }
            .caret {
                font-size: 14px;
                line-height: 1;
                width: 18px;
                text-align: center;
                user-select: none;
            }
            .caret-btn {
                background: none;
                border: none;
                cursor: pointer;
                padding: 4px; /* Increases clickable area */
                margin: -4px; /* Offsets padding */
                border-radius: 8px;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            .footer {
                position: absolute;
                right: 16px;
                bottom: 16px;
                background: var(--bg);
                padding: 8px 10px;
                border-radius: 10px;
                box-shadow: var(--shadow);
                display: flex;
                align-items: center;
                gap: 8px;
                padding-right: 42px; /* Make space for collapse button */
            }
            select {
                padding: 6px 8px;
                border-radius: 8px;
            }
            .marker {
                display: block;
                border: none;
                border-radius: 50%;
                cursor: pointer;
                width: 32px;
                height: 32px;
                background-color: #18ffff; /* Vibrant cyan color */
                -webkit-mask-image: url(assets/school-20.png);
                mask-image: url(assets/school-20.png);
                -webkit-mask-size: contain;
                mask-size: contain;
                -webkit-mask-repeat: no-repeat;
                mask-repeat: no-repeat;
                -webkit-mask-position: center;
                mask-position: center;
            }
            .popup-img {
                width: 280px;
                max-width: 90vw;
                height: auto;
                border-radius: 10px;
                display: block;
                margin: 0 0 8px 0;
            }
            .popup-summary {
                font-size: 14px;
                line-height: 1.6;
            }
            .popup-summary p {
                margin: 4px 0;
                display: flex;
                align-items: center;
                gap: 8px;
            }
            .popup-summary .status-icon {
                font-size: 18px;
                line-height: 1;
            }
            .faq-panel {
                position: absolute;
                bottom: 16px;
                left: 16px;
                background: var(--bg);
                border-radius: 14px;
                box-shadow: var(--shadow);
                z-index: 100;
                max-width: 350px;
                font-size: 14px;
            }
            .faq-panel h3 {
                padding: 10px 14px;
                font-weight: 700;
                margin: 0;
                border-bottom: 1px solid #eee;
                padding-left: 30px; /* Space for collapse button */
            }
            .faq-content {
                padding: 0 16px 12px 16px;
                max-height: 50vh;
                overflow-y: auto;
            }
            .faq-content h4 {
                margin: 12px 0 4px 0;
                font-size: 15px;
                color: #333;
            }
            .faq-content p {
                margin: 0 0 10px 0;
                font-size: 13px;
                line-height: 1.5;
                color: #555;
            }
            .stats-panel {
                position: absolute;
                top: 16px;
                right: 16px;
                background: var(--bg);
                border-radius: 14px;
                box-shadow: var(--shadow);
                z-index: 100;
                font-size: 13px;
                width: 280px;
                max-height: calc(100vh - 32px);
                overflow-y: auto;
            }
            .stats-panel h3 {
                padding: 10px 14px;
                font-weight: 700;
                cursor: default;
                outline: none;
                margin: 0;
                border-bottom: 1px solid #eee;
                padding-right: 30px; /* Space for collapse button */
            }
            .stats-content {
                padding: 4px 14px 12px 14px;
            }
            .stats-content .stat-item {
                display: flex;
                justify-content: space-between;
                padding: 4px 0;
                align-items: center;
            }
            .stats-content .stat-item b {
                font-size: 15px;
                color: #007bff;
            }
            .stats-content .hood-details {
                margin-left: 10px;
                border-left: 2px solid #eef;
                padding-left: 10px;
            }
            .stats-content .hood-details summary {
                padding: 6px;
                font-weight: normal;
            }
            .clip-btn {
                background: none;
                border: none;
                cursor: pointer;
                padding: 4px;
                margin-left: auto; /* Pushes it to the right */
                opacity: 0.5;
                transition: opacity 0.2s, color 0.2s;
                color: #555;
            }
            .clip-btn:hover {
                opacity: 1;
            }
            .clip-btn.active {
                opacity: 1;
                color: #007bff;
            }
            .panel-toggle {
                position: absolute;
                z-index: 101;
                background: var(--bg);
                border-radius: 10px;
                box-shadow: var(--shadow);
                border: none;
                cursor: pointer;
                width: 38px;
                height: 38px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 20px;
                line-height: 1;
                transition: background 0.2s;
                user-select: none;
            }
            .panel-toggle:hover {
                background: #f6f8ff;
            }
            #layers-toggle {
                top: 16px;
                left: 16px;
            }
            #stats-toggle {
                top: 16px;
                right: 16px;
            }
            #faq-toggle {
                bottom: 16px;
                left: 16px;
            }
            #basemap-toggle-btn {
                bottom: 16px;
                right: 16px;
            }
            .panel-collapse-btn {
                position: absolute;
                background: none;
                border: none;
                cursor: pointer;
                width: 32px;
                height: 32px;
                display: flex;
                align-items: center;
                justify-content: center;
                color: #aaa;
                border-radius: 8px;
                z-index: 1;
            }
            .panel-collapse-btn:hover {
                background: #f0f0f0;
                color: #111;
            }
            #layers-panel .panel-collapse-btn {
                top: 6px;
                left: 6px;
            }
            #stats-panel .panel-collapse-btn {
                top: 6px;
                right: 6px;
            }
            #faq-panel .panel-collapse-btn {
                bottom: 6px;
                left: 6px;
            }
            #footer-panel .panel-collapse-btn {
                bottom: 6px;
                right: 6px;
            }
        </style>
    </head>
    <body>
        <div id="map"></div>

        <button id="layers-toggle" class="panel-toggle" title="Straturi">‚ò∞</button>
        <div class="panel" id="layers-panel">
            <button class="panel-collapse-btn" title="Restr√¢nge">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="17" y1="17" x2="7" y2="7"></line>
                    <polyline points="7 17 7 7 17 7"></polyline>
                </svg>
            </button>
            <h3>Layere</h3>
            <div id="layers"></div>
        </div>

        <button id="basemap-toggle-btn" class="panel-toggle" title="HartƒÉ de bazƒÉ">üó∫Ô∏è</button>
        <div class="footer" id="footer-panel">
            <label for="basemap-toggle">BazƒÉ:</label>
            <select id="basemap-toggle"></select>
            <button class="panel-collapse-btn" title="Restr√¢nge">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="7" y1="7" x2="17" y2="17"></line>
                    <polyline points="17 7 17 17 7 17"></polyline>
                </svg>
            </button>
        </div>

        <button id="stats-toggle" class="panel-toggle" title="Statistici">üìä</button>
        <div class="stats-panel" id="stats-panel">
            <button class="panel-collapse-btn" title="Restr√¢nge">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="7" y1="17" x2="17" y2="7"></line>
                    <polyline points="7 7 17 7 17 17"></polyline>
                </svg>
            </button>
            <h3>Statistici</h3>
            <div class="stats-content" id="stats-content">Se √ÆncarcƒÉ...</div>
        </div>

        <button id="faq-toggle" class="panel-toggle" title="√éntrebƒÉri Frecvente">?</button>
        <div class="faq-panel" id="faq-panel">
            <button class="panel-collapse-btn" title="Restr√¢nge">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="17" y1="7" x2="7" y2="17"></line>
                    <polyline points="17 17 7 17 7 7"></polyline>
                </svg>
            </button>
            <h3>√éntrebƒÉri Frecvente (FAQ)</h3>
            <div class="faq-content">
                <h4>Ce reprezintƒÉ stratul "ParcƒÉri ilegale pe trotuar"?</h4>
                <p>Acest strat eviden»õiazƒÉ segmentele de stradƒÉ unde parcarea pe trotuar, de»ôi practicatƒÉ, nu lasƒÉ spa»õiul minim legal pentru pietoni, sau spa»õiu minim pentru piste de biciclete propuse. Conform legisla»õiei, trebuie asigurat un coridor liber de cel pu»õin 1 metru pentru pietoni.</p>

                <h4>Ce √ÆnseamnƒÉ "ParcƒÉri amenajate pe trotuar"?</h4>
                <p>Acest strat indicƒÉ zonele unde parcarea pe trotuar este amenajatƒÉ »ôi marcatƒÉ, de obicei ca parcƒÉri reziden»õiale.</p>

                <h4>Ce sunt Izocronele?</h4>
                <p>O izocronƒÉ este o hartƒÉ care aratƒÉ zonele ce pot fi atinse dintr-un punct dat √Æntr-un anumit interval de timp. Pe aceastƒÉ hartƒÉ, benzile colorate din jurul unei »ôcoli aratƒÉ c√¢t de departe se poate ajunge pe jos (pietonal) sau cu bicicleta (ciclopietonal) √Æn interval de 5, 10, respectiv 15 minute. Acest lucru ajutƒÉ la vizualizarea accesibilitƒÉ»õii »ôcolilor.</p>
            </div>
        </div>

        <script>
            const baseMaps = [
                { name: "OpenStreetMap", style: "https://raw.githubusercontent.com/go2garret/maps/main/src/assets/json/openStreetMap.json" },
                {
                    name: "Google-like",
                    style: {
                        version: 8,
                        sources: {
                            cartoLight: {
                                type: "raster",
                                tiles: ["https://cartodb-basemaps-a.global.ssl.fastly.net/light_all/{z}/{x}/{y}{scale}.png", "https://cartodb-basemaps-b.global.ssl.fastly.net/light_all/{z}/{x}/{y}{scale}.png", "https://cartodb-basemaps-c.global.ssl.fastly.net/light_all/{z}/{x}/{y}{scale}.png", "https://cartodb-basemaps-d.global.ssl.fastly.net/light_all/{z}/{x}/{y}{scale}.png"],
                                tileSize: 256,
                                attribution: "¬© OpenStreetMap contributors ¬© CARTO",
                            },
                        },
                        layers: [
                            {
                                id: "cartoLight",
                                type: "raster",
                                source: "cartoLight",
                                minzoom: 0,
                                maxzoom: 20,
                            },
                        ],
                    },
                },
                {
                    name: "Dark (OSM / CARTO)",
                    style: {
                        version: 8,
                        sources: {
                            cartoDark: {
                                type: "raster",
                                tiles: ["https://cartodb-basemaps-a.global.ssl.fastly.net/dark_all/{z}/{x}/{y}{scale}.png", "https://cartodb-basemaps-b.global.ssl.fastly.net/dark_all/{z}/{x}/{y}{scale}.png", "https://cartodb-basemaps-c.global.ssl.fastly.net/dark_all/{z}/{x}/{y}{scale}.png", "https://cartodb-basemaps-d.global.ssl.fastly.net/dark_all/{z}/{x}/{y}{scale}.png"],
                                tileSize: 256,
                                attribution: "¬© OpenStreetMap contributors ¬© CARTO",
                            },
                        },
                        layers: [{ id: "cartoDark", type: "raster", source: "cartoDark", minzoom: 0, maxzoom: 20 }],
                    },
                },
                { name: "None", style: { version: 8, sources: {}, layers: [] } },
            ];

            const NS = "nb";
            const lid = (...parts) => NS + "__" + parts.join("__");
            const isOurLayerId = (id) => id && id.indexOf(NS + "__") === 0;
            const splitId = (id) => (isOurLayerId(id) ? id.slice(NS.length + 2).split("__") : []);
            const safeDomId = (prefix, key) => prefix + "_" + btoa(key).replace(/=+/g, "");
            const pretty = (s) =>
                String(s || "")
                    .replace(/_/g, " ")
                    .replace(/\b\w/g, (m) => m.toUpperCase());

            const BIKE_EXPR = ["==", ["get", "bike_lane"], true];
            const ILLEGAL_PARKING_EXPR = ["==", ["get", "illgl_park"], true];
            const RESERVED_PARKING_EXPR = ["==", ["get", "rsrvd_park"], true];

            const walkingColors = { "0-5": "#A7FFEB", "5-10": "#64FFDA", "10-15": "#18FFFF", "15+": "#00E5FF" };
            const cyclingColors = { "0-5": "#B388FF", "5-10": "#7C4DFF", "10-15": "#651FFF", "15+": "#6200EA" };
            const bandColorExpr = (colors) => ["match", ["get", "band"], "0-5", colors["0-5"], "5-10", colors["5-10"], "10-15", colors["10-15"], "15+", colors["15+"], colors["0-5"]];
            const BAND_OPACITY_EXPR = ["match", ["get", "band"], "0-5", 0.65, "5-10", 0.55, "10-15", 0.45, "15+", 0.35, 0.5];
            const BAND_SORT_KEY_EXPR = ["match", ["get", "band"], "0-5", 3, "5-10", 2, "10-15", 1, "15+", 0, 0];
            const MAP_DARK_BG = getComputedStyle(document.documentElement).getPropertyValue("--map-dark-bg").trim();

            const map = new maplibregl.Map({
                container: "map",
                style: baseMaps[2].style,
                center: [24.161728, 45.790919],
                zoom: 14,
            });

            const basemapSelect = document.getElementById("basemap-toggle");
            baseMaps.forEach((bm, i) => {
                const o = document.createElement("option");
                o.value = i;
                o.textContent = bm.name;
                basemapSelect.appendChild(o);
            });
            basemapSelect.value = 2;
            basemapSelect.addEventListener("change", function () {
                map.setStyle(baseMaps[+this.value].style, { diff: false });
            });

            const data = {
                streets: null,
                schools: null,
                neighborhoodLimits: null,
                neighborhoods: [],
                byNeighborhood: {},
                schoolsIndex: {},
                isochrones: {},
                neighborhoodLimitsIndex: {},
            };

            const state = {
                visible: new Map(),
                expanded: new Map(),
                markers: new Map(),
                isoLoaded: new Set(),
                preloaded: false,
            };

            let streetLayerIds = [];
            let hoverCursorBound = false;
            let clickBound = false;

            (async function preloadAll() {
                try {
                    const [streets, schools, neighborhoodLimits] = await Promise.all([fetch("streets.geojson", { cache: "no-store" }).then((r) => r.json()), fetch("schools.geojson", { cache: "no-store" }).then((r) => r.json()), fetch("neighborhood_limits.geojson", { cache: "no-store" }).then((r) => r.json())]);
                    data.streets = streets;
                    data.schools = schools;
                    data.neighborhoodLimits = neighborhoodLimits;
                    indexData();
                    calculateAndDisplayStats();
                    await prefetchIsochrones();
                    buildUI();
                    setupPanelToggles();
                    state.preloaded = true;
                    if (map.isStyleLoaded()) reinstallOverlays();
                } catch (e) {
                    console.error("Preload failed:", e);
                    document.getElementById("layers").innerHTML = "Nu s-au putut √ÆncƒÉrca fi»ôierele .geojson";
                }
            })();

            let debounceTimer = null;
            map.on("styledata", () => {
                if (!state.preloaded) return;
                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(() => reinstallOverlays(), 0);
            });
            map.on("load", () => {
                if (state.preloaded) reinstallOverlays();
            });
            map.on("idle", () => {
                if (!state.preloaded) return;
                if (!overlaySentinelPresent()) reinstallOverlays();
            });

            function overlaySentinelPresent() {
                if (data.neighborhoods.length === 0) return true;
                const first = data.neighborhoods[0].slug;
                return !!map.getLayer(lid(first, "bg"));
            }

            function reinstallOverlays() {
                state.isoLoaded.clear();
                addAllLayersFromMemory();
                addIsoLayersForAnyChecked();
                ensureCorrectLayerOrder();
                applyAllVisibility();
                syncAllMarkers();
                bindGlobalStreetInteractivity();
            }

            function indexData() {
                // 1. Use neighborhood_limits.geojson as the source of truth for neighborhoods.
                data.neighborhoods = [];
                const slugToNameMap = new Map();
                data.neighborhoodLimitsIndex = {};

                if (data.neighborhoodLimits && data.neighborhoodLimits.features) {
                    for (const feature of data.neighborhoodLimits.features) {
                        const props = feature.properties;
                        if (props && props.denumire && props.slug) {
                            data.neighborhoods.push({ name: props.denumire, slug: props.slug });
                            slugToNameMap.set(props.slug, props.denumire);
                            data.neighborhoodLimitsIndex[props.slug] = feature;
                        }
                    }
                }
                data.neighborhoods.sort((a, b) => a.name.localeCompare(b.name));

                // 2. Group streets by their neighborhood slug (`p.cartier`).
                const byHood = {};
                const feats = data.streets && data.streets.features ? data.streets.features : [];
                for (let f of feats) {
                    const p = f.properties || {};
                    const hid = p.cartier || null; // This is the SLUG.
                    if (!hid || !slugToNameMap.has(hid)) {
                        continue;
                    }

                    if (!byHood[hid]) byHood[hid] = { features: [], schoolsSet: {} };
                    byHood[hid].features.push(f);
                    const s = p.arondat || null;
                    if (s) byHood[hid].schoolsSet[s] = true;
                }

                // 3. Finalize the `byNeighborhood` data structure.
                data.byNeighborhood = {};
                for (let { slug: hid } of data.neighborhoods) {
                    const hoodData = byHood[hid] || { features: [], schoolsSet: {} };
                    data.byNeighborhood[hid] = {
                        features: hoodData.features,
                        schools: Object.keys(hoodData.schoolsSet).sort(),
                    };
                    console.log("Neighborhood", hid, "has", hoodData.features.length, "street features and", Object.keys(hoodData.schoolsSet).length, "schools assigned.");
                }

                // 4. Index schools using the 'slug' property directly.
                data.schoolsIndex = {};
                const sFeats = data.schools && data.schools.features ? data.schools.features : [];
                for (let sf of sFeats) {
                    const sp = sf.properties || {};
                    const sslug = sp.slug; // <-- CORRECT: Use the slug from the GeoJSON.
                    if (!sslug) {
                        console.warn("School feature is missing a 'slug' property, skipping:", sp);
                        continue;
                    }
                    const nm = sp.denumire || sp.name || "";
                    const numMatch = nm.match(/\d+/);

                    data.schoolsIndex[sslug] = {
                        name: nm,
                        coord: sf.geometry && sf.geometry.coordinates,
                        number: numMatch ? numMatch[0] : null,
                    };
                }
            }

            async function prefetchIsochrones() {
                data.isochrones = {};
                for (let sslug in data.schoolsIndex) {
                    data.isochrones[sslug] = {
                        walk: { type: "FeatureCollection", features: [] },
                        cycle: { type: "FeatureCollection", features: [] },
                    };
                }

                try {
                    const response = await fetch("school_isochrones.geojson", { cache: "no-store" });
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const allIsochrones = await response.json();

                    if (allIsochrones && allIsochrones.features) {
                        for (const feature of allIsochrones.features) {
                            const p = feature.properties;
                            if (!p || !p.den_scoala || !p.tip || p.cost_level === undefined) continue;

                            const sslug = p.den_scoala;
                            const type = p.tip;
                            const cost = p.cost_level;

                            if (cost <= 300) feature.properties.band = "0-5";
                            else if (cost <= 600) feature.properties.band = "5-10";
                            else if (cost <= 900) feature.properties.band = "10-15";
                            else feature.properties.band = "15+";

                            if (data.isochrones[sslug]) {
                                if (type === "walking") {
                                    data.isochrones[sslug].walk.features.push(feature);
                                } else if (type === "cycling") {
                                    data.isochrones[sslug].cycle.features.push(feature);
                                }
                            }
                        }
                    }
                    for (let sslug in data.isochrones) {
                        if (data.isochrones[sslug].walk.features.length === 0) data.isochrones[sslug].walk = null;
                        if (data.isochrones[sslug].cycle.features.length === 0) data.isochrones[sslug].cycle = null;
                    }
                } catch (e) {
                    console.error("Failed to load or process school_isochrones.geojson:", e);
                    for (let sslug in data.isochrones) {
                        data.isochrones[sslug].walk = null;
                        data.isochrones[sslug].cycle = null;
                    }
                }
            }

            const srcIdForHood = (hid) => NS + "_src__" + hid;

            function ensureHoodSource(hid) {
                const sid = srcIdForHood(hid);
                if (!map.getSource(sid)) {
                    map.addSource(sid, { type: "geojson", data: { type: "FeatureCollection", features: data.byNeighborhood[hid].features } });
                }
            }

            function createMaskGeoJSON(boundaryFeature) {
                if (!boundaryFeature || !boundaryFeature.geometry || !boundaryFeature.geometry.coordinates) return null;
                const boundaryCoords = boundaryFeature.geometry.type === "Polygon" ? boundaryFeature.geometry.coordinates[0] : boundaryFeature.geometry.coordinates[0][0];
                return {
                    type: "Feature",
                    geometry: {
                        type: "Polygon",
                        coordinates: [
                            [
                                [-180, -90],
                                [180, -90],
                                [180, 90],
                                [-180, 90],
                                [-180, -90],
                            ],
                            boundaryCoords,
                        ],
                    },
                };
            }

            function addAllLayersFromMemory() {
                streetLayerIds = [];

                for (let { slug: hid } of data.neighborhoods) {
                    ensureHoodSource(hid);
                    const bgId = lid(hid, "bg");
                    if (!map.getLayer(bgId)) map.addLayer({ id: bgId, type: "line", source: srcIdForHood(hid), paint: { "line-color": "#666", "line-width": 4, "line-opacity": 0.8 }, layout: { visibility: "none", "line-cap": "round", "line-join": "round" } });
                    streetLayerIds.push(bgId);

                    const bikeId = lid(hid, "bike");
                    if (!map.getLayer(bikeId)) map.addLayer({ id: bikeId, type: "line", source: srcIdForHood(hid), filter: BIKE_EXPR, paint: { "line-color": "#00FF88", "line-width": 5, "line-opacity": 0.9 }, layout: { visibility: "none", "line-cap": "round", "line-join": "round" } });
                    streetLayerIds.push(bikeId);

                    const reservedParkingId = lid(hid, "reserved_parking");
                    if (!map.getLayer(reservedParkingId)) map.addLayer({ id: reservedParkingId, type: "line", source: srcIdForHood(hid), filter: RESERVED_PARKING_EXPR, paint: { "line-color": "#F50057", "line-width": 5, "line-opacity": 0.9 }, layout: { visibility: "none", "line-cap": "round", "line-join": "round" } });
                    streetLayerIds.push(reservedParkingId);

                    const illegalParkingId = lid(hid, "illegal_parking");
                    if (!map.getLayer(illegalParkingId)) map.addLayer({ id: illegalParkingId, type: "line", source: srcIdForHood(hid), filter: ILLEGAL_PARKING_EXPR, paint: { "line-color": "#FFD600", "line-width": 5, "line-opacity": 0.9 }, layout: { visibility: "none", "line-cap": "round", "line-join": "round" } });
                    streetLayerIds.push(illegalParkingId);

                    const schools = data.byNeighborhood[hid].schools;
                    for (let sslug of schools) {
                        const assignedId = lid(hid, "schools", sslug, "assigned");
                        if (!map.getLayer(assignedId)) map.addLayer({ id: assignedId, type: "line", source: srcIdForHood(hid), filter: ["==", ["get", "arondat"], sslug], paint: { "line-color": "#ff9100", "line-width": 8, "line-opacity": 0.8 }, layout: { visibility: "none", "line-cap": "round", "line-join": "round" } });
                        streetLayerIds.push(assignedId);
                    }

                    const boundaryFeature = data.neighborhoodLimitsIndex[hid];
                    if (boundaryFeature) {
                        const limitSrcId = lid(hid, "limit_src");
                        const maskSrcId = lid(hid, "mask_src");
                        if (!map.getSource(limitSrcId)) map.addSource(limitSrcId, { type: "geojson", data: boundaryFeature });

                        const maskGeoJSON = createMaskGeoJSON(boundaryFeature);
                        if (maskGeoJSON && !map.getSource(maskSrcId)) map.addSource(maskSrcId, { type: "geojson", data: maskGeoJSON });

                        const maskLayerId = lid(hid, "mask");
                        if (!map.getLayer(maskLayerId)) map.addLayer({ id: maskLayerId, type: "fill", source: maskSrcId, paint: { "fill-color": MAP_DARK_BG, "fill-opacity": 1 }, layout: { visibility: "none" } });

                        const limitLayerId = lid(hid, "limit");
                        if (!map.getLayer(limitLayerId)) map.addLayer({ id: limitLayerId, type: "line", source: limitSrcId, paint: { "line-color": "#00BFFF", "line-width": 10, "line-opacity": 0.9 }, layout: { visibility: "none" } });
                    }
                }
            }

            function addIsoLayersIfNeeded(hid, sslug) {
                const bucket = data.isochrones[sslug];
                if (!bucket) return;
                const files = [
                    { kind: "cycle", gj: bucket.cycle, stroke: "#FF00FF" },
                    { kind: "walk", gj: bucket.walk, stroke: "#ADFF2F" },
                ];
                for (let f of files) {
                    if (!f.gj) continue;
                    const srcId = lid("iso_src", sslug, f.kind);
                    const fillId = lid(hid, "schools", sslug, "iso", f.kind + "_fill");
                    const lineId = lid(hid, "schools", sslug, "iso", f.kind + "_stroke");
                    const loadedKey = fillId + "::loaded";
                    if (state.isoLoaded.has(loadedKey)) continue;

                    if (!map.getSource(srcId)) map.addSource(srcId, { type: "geojson", data: f.gj });
                    const colors = f.kind === "walk" ? walkingColors : cyclingColors;
                    if (!map.getLayer(fillId)) map.addLayer({ id: fillId, type: "fill", source: srcId, paint: { "fill-color": bandColorExpr(colors), "fill-opacity": BAND_OPACITY_EXPR }, layout: { visibility: "none", "fill-sort-key": BAND_SORT_KEY_EXPR } });
                    if (!map.getLayer(lineId)) map.addLayer({ id: lineId, type: "line", source: srcId, paint: { "line-color": f.stroke, "line-width": 2.5 }, layout: { visibility: "none" } });
                    state.isoLoaded.add(loadedKey);
                }
                ensureCorrectLayerOrder();
            }

            function addIsoLayersForAnyChecked() {
                for (let { slug: hid } of data.neighborhoods) {
                    const slugs = data.byNeighborhood[hid].schools;
                    for (let sslug of slugs) {
                        const isoParentOn = state.visible.get(lid(hid, "schools", sslug, "iso")) === true;
                        const anyChildOn = state.visible.get(lid(hid, "schools", sslug, "iso", "walk_fill")) === true || state.visible.get(lid(hid, "schools", sslug, "iso", "cycle_fill")) === true;
                        if (isoParentOn && anyChildOn) addIsoLayersIfNeeded(hid, sslug);
                    }
                }
            }

            function ensureCorrectLayerOrder() {
                map.once("idle", () => {
                    const allLayers = map.getStyle().layers;
                    const ourLayerIds = allLayers.map((l) => l.id).filter((id) => isOurLayerId(id));
                    const layerGroups = {
                        isos: ourLayerIds.filter((id) => id.includes("__iso_")),
                        streets: ourLayerIds.filter((id) => !id.includes("__iso_") && !id.includes("__limit") && !id.includes("__mask")),
                        masks: ourLayerIds.filter((id) => id.includes("__mask")),
                        limits: ourLayerIds.filter((id) => id.includes("__limit")),
                    };
                    const firstMapLabel = allLayers.find((l) => l.type === "symbol")?.id;
                    const orderedLayers = [...layerGroups.isos, ...layerGroups.streets, ...layerGroups.masks, ...layerGroups.limits];
                    for (const layerId of orderedLayers) {
                        if (map.getLayer(layerId)) {
                            try {
                                if (firstMapLabel) map.moveLayer(layerId, firstMapLabel);
                                else map.moveLayer(layerId);
                            } catch (e) {
                                console.warn(`Could not move layer ${layerId}:`, e.message);
                            }
                        }
                    }
                });
            }

            function keysRequiredForLayer(layerIdStr) {
                const parts = splitId(layerIdStr);
                if (!parts.length) return null;
                const keys = [];
                const hid = parts[0];
                if (parts[1] === "limit") return [lid(hid)];
                if (parts[1] === "mask") return [lid(hid), lid(hid, "clipping")];
                keys.push(lid(hid));
                if (parts[1] === "bg") {
                    keys.push(lid(hid, "streets"));
                    return keys;
                }
                if (["bike", "illegal_parking", "reserved_parking"].includes(parts[1])) {
                    keys.push(lid(hid, "streets"));
                    keys.push(lid(hid, parts[1]));
                    return keys;
                }
                if (parts[1] === "schools") {
                    keys.push(lid(hid, "schools"));
                    if (parts.length >= 3) {
                        const sslug = parts[2];
                        keys.push(lid(hid, "schools", sslug));
                        if (parts.length >= 4) {
                            if (parts[3] === "assigned") {
                                keys.push(lid(hid, "schools", sslug, "assigned"));
                                return keys;
                            }
                            if (parts[3] === "iso") {
                                keys.push(lid(hid, "schools", sslug, "iso"));
                                if (parts.length >= 5) keys.push(lid(...parts));
                                return keys;
                            }
                        }
                    }
                }
                return [];
            }

            function applyAllVisibility() {
                const style = map.getStyle();
                if (!style || !style.layers) return;
                for (let L of style.layers.map((x) => x.id)) {
                    if (!isOurLayerId(L)) continue;
                    const req = keysRequiredForLayer(L);
                    if (!req) continue;
                    let visible = true;
                    for (let k of req) {
                        if (state.visible.get(k) !== true) {
                            visible = false;
                            break;
                        }
                    }
                    try {
                        map.setLayoutProperty(L, "visibility", visible ? "visible" : "none");
                    } catch (_) {}
                }
            }

            function syncAllMarkers() {
                for (let { slug: hid } of data.neighborhoods) {
                    for (let sslug of data.byNeighborhood[hid].schools) {
                        syncSchoolMarker(hid, sslug);
                    }
                }
            }

            function syncSchoolMarker(hid, sslug) {
                const key = lid(hid, "schools", sslug);
                const req = [lid(hid), lid(hid, "schools"), key];
                const eff = req.every((k) => state.visible.get(k) === true);
                const idx = data.schoolsIndex[sslug];
                if (!idx || !idx.coord) return;
                const existing = state.markers.get(key);
                if (eff && !existing) {
                    const el = document.createElement("button");
                    el.className = "marker";
                    el.title = idx.name || "»òcoalƒÉ";
                    const m = new maplibregl.Marker({ element: el }).setLngLat(idx.coord).addTo(map);
                    state.markers.set(key, m);
                }
                if (!eff && existing) {
                    existing.remove();
                    state.markers.delete(key);
                }
            }

            function makeRow(key, label, checked, chipColor, isGroup) {
                const row = document.createElement("div");
                row.className = "row";
                const caretBtn = document.createElement("button");
                caretBtn.className = "caret-btn";
                caretBtn.type = "button";
                const caret = document.createElement("span");
                caret.className = "caret";
                caret.textContent = isGroup ? (state.expanded.get(key) === false ? "‚ñ∏" : "‚ñæ") : "";
                caretBtn.appendChild(caret);
                const cb = document.createElement("input");
                cb.type = "checkbox";
                cb.checked = !!checked;
                cb.id = safeDomId("cb", key);
                const chip = document.createElement("span");
                chip.className = "chip";
                if (chipColor) chip.style.background = chipColor;
                const lbl = document.createElement("label");
                lbl.htmlFor = cb.id;
                lbl.textContent = label;
                if (isGroup) row.appendChild(caretBtn);
                else {
                    const spacer = document.createElement("span");
                    spacer.className = "caret";
                    spacer.textContent = "";
                    row.appendChild(spacer);
                }
                row.appendChild(cb);
                if (chipColor) row.appendChild(chip);
                row.appendChild(lbl);
                return { row, cb, caretBtn, caret };
            }

            function buildUI() {
                const host = document.getElementById("layers");
                host.innerHTML = "";
                for (let { slug: hid, name: hname } of data.neighborhoods) {
                    const hoodKey = lid(hid);
                    if (!state.visible.has(hoodKey)) state.visible.set(hoodKey, true);
                    if (!state.expanded.has(hoodKey)) state.expanded.set(hoodKey, false);
                    const hasBoundary = !!data.neighborhoodLimitsIndex[hid];
                    const hoodChipColor = hasBoundary ? "#00BFFF" : null;
                    const wrap = document.createElement("div");
                    wrap.className = "group";
                    const hoodHeader = makeRow(hoodKey, "Cartierul " + hname, state.visible.get(hoodKey), hoodChipColor, true);
                    if (hasBoundary) {
                        const clippingKey = lid(hid, "clipping");
                        if (!state.visible.has(clippingKey)) state.visible.set(clippingKey, false);
                        const clipBtn = document.createElement("button");
                        clipBtn.className = "clip-btn";
                        clipBtn.title = "Taie la limitƒÉ";
                        clipBtn.innerHTML = `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="6" cy="6" r="3"></circle><circle cx="6" cy="18" r="3"></circle><line x1="20" y1="4" x2="8.12" y2="15.88"></line><line x1="14.47" y1="14.48" x2="20" y2="20"></line><line x1="8.12" y1="8.12" x2="12" y2="12"></line></svg>`;
                        if (state.visible.get(clippingKey)) clipBtn.classList.add("active");
                        clipBtn.addEventListener("click", (e) => {
                            e.stopPropagation();
                            const isActive = !state.visible.get(clippingKey);
                            state.visible.set(clippingKey, isActive);
                            clipBtn.classList.toggle("active", isActive);
                            applyAllVisibility();
                        });
                        hoodHeader.row.appendChild(clipBtn);
                    }
                    wrap.appendChild(hoodHeader.row);
                    const hoodBody = document.createElement("div");
                    hoodBody.className = "indent";
                    hoodBody.style.display = state.expanded.get(hoodKey) === false ? "none" : "";
                    const streetsHeaderKey = lid(hid, "streets");
                    const bgKey = lid(hid, "bg");
                    if (!state.visible.has(streetsHeaderKey)) state.visible.set(streetsHeaderKey, true);
                    if (!state.visible.has(bgKey)) state.visible.set(bgKey, true);
                    if (!state.expanded.has(streetsHeaderKey)) state.expanded.set(streetsHeaderKey, false);
                    const streetsHeader = makeRow(streetsHeaderKey, "StrƒÉzi", state.visible.get(streetsHeaderKey), "#666", true);
                    const streetsBody = document.createElement("div");
                    streetsBody.className = "indent";
                    streetsBody.style.display = state.expanded.get(streetsHeaderKey) === false ? "none" : "";
                    const bikeKey = lid(hid, "bike");
                    if (!state.visible.has(bikeKey)) state.visible.set(bikeKey, true);
                    const reservedParkingKey = lid(hid, "reserved_parking");
                    if (!state.visible.has(reservedParkingKey)) state.visible.set(reservedParkingKey, true);
                    const illegalParkingKey = lid(hid, "illegal_parking");
                    if (!state.visible.has(illegalParkingKey)) state.visible.set(illegalParkingKey, true);
                    const bikeRow = makeRow(bikeKey, "PistƒÉ de biciclete", state.visible.get(bikeKey), "#00FF88", false);
                    const reservedParkingRow = makeRow(reservedParkingKey, "ParcƒÉri amenajate pe trotuar", state.visible.get(reservedParkingKey), "#F50057", false);
                    const illegalParkingRow = makeRow(illegalParkingKey, "ParcƒÉri ilegale pe trotuar", state.visible.get(illegalParkingKey), "#FFD600", false);
                    streetsBody.appendChild(bikeRow.row);
                    streetsBody.appendChild(reservedParkingRow.row);
                    streetsBody.appendChild(illegalParkingRow.row);
                    hoodBody.appendChild(streetsHeader.row);
                    hoodBody.appendChild(streetsBody);

                    const schoolSlugs = data.byNeighborhood[hid].schools;
                    const createSchoolUI = (sslug, parent) => {
                        const schoolKey = lid(hid, "schools", sslug);
                        if (!state.visible.has(schoolKey)) state.visible.set(schoolKey, true);
                        if (!state.expanded.has(schoolKey)) state.expanded.set(schoolKey, false);
                        const sHeader = makeRow(schoolKey, data.schoolsIndex[sslug] ? data.schoolsIndex[sslug].name : pretty(sslug), state.visible.get(schoolKey), null, true);
                        const sBody = document.createElement("div");
                        sBody.className = "indent";
                        sBody.style.display = state.expanded.get(schoolKey) === false ? "none" : "";
                        const assignedKey = lid(hid, "schools", sslug, "assigned");
                        if (!state.visible.has(assignedKey)) state.visible.set(assignedKey, false);
                        const assignedRow = makeRow(assignedKey, "StrƒÉzi arondate", state.visible.get(assignedKey), "#ff9100", false);
                        const isoHeaderKey = lid(hid, "schools", sslug, "iso");
                        if (!state.visible.has(isoHeaderKey)) state.visible.set(isoHeaderKey, true);
                        if (!state.expanded.has(isoHeaderKey)) state.expanded.set(isoHeaderKey, false);
                        const isoHeader = makeRow(isoHeaderKey, "Izocrone", state.visible.get(isoHeaderKey), null, true);
                        const isoBody = document.createElement("div");
                        isoBody.className = "indent";
                        isoBody.style.display = state.expanded.get(isoHeaderKey) === false ? "none" : "";
                        const walkFill = lid(hid, "schools", sslug, "iso", "walk_fill");
                        const walkStroke = lid(hid, "schools", sslug, "iso", "walk_stroke");
                        const cycleFill = lid(hid, "schools", sslug, "iso", "cycle_fill");
                        const cycleStroke = lid(hid, "schools", sslug, "iso", "cycle_stroke");
                        [walkFill, walkStroke].forEach((k) => {
                            if (!state.visible.has(k)) state.visible.set(k, false);
                        });
                        [cycleFill, cycleStroke].forEach((k) => {
                            if (!state.visible.has(k)) state.visible.set(k, true);
                        });
                        const walkRow = makeRow(walkFill, "Pietonal", state.visible.get(walkFill), walkingColors["10-15"], false);
                        const cycleRow = makeRow(cycleFill, "Ciclopietonal", state.visible.get(cycleFill), cyclingColors["10-15"], false);
                        isoBody.appendChild(walkRow.row);
                        isoBody.appendChild(cycleRow.row);
                        sBody.appendChild(assignedRow.row);
                        sBody.appendChild(isoHeader.row);
                        sBody.appendChild(isoBody);
                        parent.appendChild(sHeader.row);
                        parent.appendChild(sBody);
                        sHeader.caretBtn.addEventListener("click", () => {
                            const cur = state.expanded.get(schoolKey) !== false;
                            state.expanded.set(schoolKey, !cur);
                            sBody.style.display = cur ? "none" : "";
                            sHeader.caret.textContent = cur ? "‚ñ∏" : "‚ñæ";
                        });
                        isoHeader.caretBtn.addEventListener("click", () => {
                            const cur = state.expanded.get(isoHeaderKey) !== false;
                            state.expanded.set(isoHeaderKey, !cur);
                            isoBody.style.display = cur ? "none" : "";
                            isoHeader.caret.textContent = cur ? "‚ñ∏" : "‚ñæ";
                        });
                        return { sHeader, assignedRow, isoHeader, walkRow, cycleRow, schoolKey, assignedKey, isoHeaderKey, walkFill, walkStroke, cycleFill, cycleStroke };
                    };

                    if (schoolSlugs.length === 1) {
                        const sslug = schoolSlugs[0];
                        const schoolsHeaderKey = lid(hid, "schools");
                        if (!state.visible.has(schoolsHeaderKey)) state.visible.set(schoolsHeaderKey, true);
                        const ui = createSchoolUI(sslug, hoodBody);
                        ui.sHeader.cb.addEventListener("change", function () {
                            state.visible.set(ui.schoolKey, this.checked);
                            state.visible.set(schoolsHeaderKey, this.checked);
                            if (this.checked && (state.visible.get(ui.walkFill) === true || state.visible.get(ui.cycleFill) === true)) addIsoLayersIfNeeded(hid, sslug);
                            applyAllVisibility();
                            syncSchoolMarker(hid, sslug);
                        });
                        ui.assignedRow.cb.addEventListener("change", function () {
                            state.visible.set(ui.assignedKey, this.checked);
                            applyAllVisibility();
                        });
                        ui.isoHeader.cb.addEventListener("change", function () {
                            state.visible.set(ui.isoHeaderKey, this.checked);
                            if (this.checked && (state.visible.get(ui.walkFill) === true || state.visible.get(ui.cycleFill) === true)) addIsoLayersIfNeeded(hid, sslug);
                            applyAllVisibility();
                        });
                        ui.walkRow.cb.addEventListener("change", function () {
                            [ui.walkFill, ui.walkStroke].forEach((k) => state.visible.set(k, this.checked));
                            addIsoLayersIfNeeded(hid, sslug);
                            applyAllVisibility();
                        });
                        ui.cycleRow.cb.addEventListener("change", function () {
                            [ui.cycleFill, ui.cycleStroke].forEach((k) => state.visible.set(k, this.checked));
                            addIsoLayersIfNeeded(hid, sslug);
                            applyAllVisibility();
                        });
                    } else if (schoolSlugs.length > 1) {
                        const schoolsHeaderKey = lid(hid, "schools");
                        if (!state.visible.has(schoolsHeaderKey)) state.visible.set(schoolsHeaderKey, true);
                        if (!state.expanded.has(schoolsHeaderKey)) state.expanded.set(schoolsHeaderKey, false);
                        const schoolsHeader = makeRow(schoolsHeaderKey, "»òcoli", state.visible.get(schoolsHeaderKey), null, true);
                        const schoolsBody = document.createElement("div");
                        schoolsBody.className = "indent";
                        schoolsBody.style.display = state.expanded.get(schoolsHeaderKey) === false ? "none" : "";
                        for (let sslug of schoolSlugs) {
                            const ui = createSchoolUI(sslug, schoolsBody);
                            ui.sHeader.cb.addEventListener("change", function () {
                                state.visible.set(ui.schoolKey, this.checked);
                                if (this.checked && (state.visible.get(ui.walkFill) === true || state.visible.get(ui.cycleFill) === true)) addIsoLayersIfNeeded(hid, sslug);
                                applyAllVisibility();
                                syncSchoolMarker(hid, sslug);
                            });
                            ui.assignedRow.cb.addEventListener("change", function () {
                                state.visible.set(ui.assignedKey, this.checked);
                                applyAllVisibility();
                            });
                            ui.isoHeader.cb.addEventListener("change", function () {
                                state.visible.set(ui.isoHeaderKey, this.checked);
                                if (this.checked && (state.visible.get(ui.walkFill) === true || state.visible.get(ui.cycleFill) === true)) addIsoLayersIfNeeded(hid, sslug);
                                applyAllVisibility();
                            });
                            ui.walkRow.cb.addEventListener("change", function () {
                                [ui.walkFill, ui.walkStroke].forEach((k) => state.visible.set(k, this.checked));
                                addIsoLayersIfNeeded(hid, sslug);
                                applyAllVisibility();
                            });
                            ui.cycleRow.cb.addEventListener("change", function () {
                                [ui.cycleFill, ui.cycleStroke].forEach((k) => state.visible.set(k, this.checked));
                                addIsoLayersIfNeeded(hid, sslug);
                                applyAllVisibility();
                            });
                        }
                        hoodBody.appendChild(schoolsHeader.row);
                        hoodBody.appendChild(schoolsBody);
                        schoolsHeader.caretBtn.addEventListener("click", () => {
                            const cur = state.expanded.get(schoolsHeaderKey) !== false;
                            state.expanded.set(schoolsHeaderKey, !cur);
                            schoolsBody.style.display = cur ? "none" : "";
                            schoolsHeader.caret.textContent = cur ? "‚ñ∏" : "‚ñæ";
                        });
                        schoolsHeader.cb.addEventListener("change", function () {
                            state.visible.set(schoolsHeaderKey, this.checked);
                            applyAllVisibility();
                            syncAllMarkers();
                        });
                    }

                    wrap.appendChild(hoodBody);
                    host.appendChild(wrap);
                    hoodHeader.caretBtn.addEventListener("click", () => {
                        const cur = state.expanded.get(hoodKey) !== false;
                        state.expanded.set(hoodKey, !cur);
                        hoodBody.style.display = cur ? "none" : "";
                        hoodHeader.caret.textContent = cur ? "‚ñ∏" : "‚ñæ";
                    });
                    hoodHeader.cb.addEventListener("change", function () {
                        state.visible.set(hoodKey, this.checked);
                        applyAllVisibility();
                        syncAllMarkers();
                    });
                    streetsHeader.caretBtn.addEventListener("click", () => {
                        const cur = state.expanded.get(streetsHeaderKey) !== false;
                        state.expanded.set(streetsHeaderKey, !cur);
                        streetsBody.style.display = cur ? "none" : "";
                        streetsHeader.caret.textContent = cur ? "‚ñ∏" : "‚ñæ";
                    });
                    streetsHeader.cb.addEventListener("change", function () {
                        state.visible.set(streetsHeaderKey, this.checked);
                        state.visible.set(bgKey, this.checked);
                        applyAllVisibility();
                    });
                    bikeRow.cb.addEventListener("change", function () {
                        state.visible.set(bikeKey, this.checked);
                        applyAllVisibility();
                    });
                    reservedParkingRow.cb.addEventListener("change", function () {
                        state.visible.set(reservedParkingKey, this.checked);
                        applyAllVisibility();
                    });
                    illegalParkingRow.cb.addEventListener("change", function () {
                        state.visible.set(illegalParkingKey, this.checked);
                        applyAllVisibility();
                    });
                }
            }

            function calculateAndDisplayStats() {
                const allFeatures = data.streets && data.streets.features ? data.streets.features : [];
                if (allFeatures.length === 0) return;
                const calcStatsFor = (features) => {
                    if (features.length === 0) return { bikeLanePercentage: "0.0", illegalParkingPercentage: "0.0" };
                    let streetsWithBikeLanes = 0;
                    let streetsWithIllegalParking = 0;
                    for (const f of features) {
                        const p = f.properties;
                        if (!p) continue;
                        if (p.bike_lane === true) streetsWithBikeLanes++;
                        if (p.illgl_park === true) streetsWithIllegalParking++;
                    }
                    return {
                        bikeLanePercentage: ((streetsWithBikeLanes / features.length) * 100).toFixed(1),
                        illegalParkingPercentage: ((streetsWithIllegalParking / features.length) * 100).toFixed(1),
                    };
                };
                const globalStats = calcStatsFor(allFeatures);
                let html = `
                <h4>Total Ora»ô</h4>
                <div class="stat-item"><span>StrƒÉzi cu pistƒÉ de biciclete:</span><b>${globalStats.bikeLanePercentage}%</b></div>
                <div class="stat-item"><span>StrƒÉzi cu parcare ilegalƒÉ:</span><b>${globalStats.illegalParkingPercentage}%</b></div>
                <hr>`;
                data.neighborhoods.forEach((hood) => {
                    const hoodFeatures = allFeatures.filter((f) => f.properties.cartier === hood.slug);
                    const hoodStats = calcStatsFor(hoodFeatures);
                    html += `
                    <details class="hood-details">
                        <summary>${hood.name}</summary>
                        <div class="stat-item"><span>StrƒÉzi cu pistƒÉ de biciclete:</span><b>${hoodStats.bikeLanePercentage}%</b></div>
                        <div class="stat-item"><span>StrƒÉzi cu parcare ilegalƒÉ:</span><b>${hoodStats.illegalParkingPercentage}%</b></div>
                    </details>
                `;
                });
                document.getElementById("stats-content").innerHTML = html;
            }

            function bindGlobalStreetInteractivity() {
                if (!hoverCursorBound) {
                    map.on("mousemove", function (e) {
                        const feats = map.queryRenderedFeatures(e.point, { layers: streetLayerIds });
                        map.getCanvas().style.cursor = feats && feats.length ? "pointer" : "";
                    });
                    hoverCursorBound = true;
                }
                const handleClick = function (e) {
                    const feats = map.queryRenderedFeatures(e.point, { layers: streetLayerIds });
                    if (!feats || !feats.length) return;
                    const f = feats[0];
                    const p = f.properties || {};
                    const title = p.name || p.denumire || "StradƒÉ";
                    let summary = "";
                    const hasBikeLane = p.bike_lane === true;
                    const hasIllegalParking = p.illgl_park === true;
                    const hasReservedParking = p.rsrvd_park === true;
                    if (hasBikeLane) {
                        summary += `<p><span class="status-icon" style="color: #00FF88;">‚úî</span> PistƒÉ de biciclete: <b>Da</b></p>`;
                    } else {
                        summary += `<p><span class="status-icon" style="color: #ff4d4d;">‚úñ</span> PistƒÉ de biciclete: <b>Nu</b></p>`;
                    }
                    if (hasIllegalParking) {
                        summary += `<p><span class="status-icon" style="color: #FFD600;">‚ö†</span> ParcƒÉri ilegale pe trotuar: <b>Da</b></p>`;
                    }
                    if (hasReservedParking) {
                        summary += `<p><span class="status-icon" style="color: #F50057;">üÖøÔ∏è</span> ParcƒÉri amenajate pe trotuar: <b>Da</b></p>`;
                    }
                    if (p.arondat && data.schoolsIndex[p.arondat]) {
                        summary += `<p><span class="status-icon">üè´</span> ArondatƒÉ la: <b>${data.schoolsIndex[p.arondat].name}</b></p>`;
                    }
                    if (summary === "") {
                        summary = "<p>Nu existƒÉ date specifice pentru aceastƒÉ stradƒÉ.</p>";
                    }
                    const html = `
            <div style="max-width:320px">
              <img class="popup-img" src="assets/street-example.jpg" alt="Exemplu stradƒÉ" />
              <div style="font-weight:700; margin:2px 0 8px 0;">${title}</div>
              <div class="popup-summary">${summary}</div>
            </div>
          `;
                    new maplibregl.Popup({ closeOnClick: true, maxWidth: "320px" }).setLngLat(e.lngLat).setHTML(html).addTo(map);
                };
                if (!clickBound) {
                    map.on("click", handleClick);
                    clickBound = true;
                }
            }

            function setupPanelToggles() {
                const configs = [
                    { buttonId: "layers-toggle", panelId: "layers-panel" },
                    { buttonId: "stats-toggle", panelId: "stats-panel" },
                    { buttonId: "faq-toggle", panelId: "faq-panel" },
                    { buttonId: "basemap-toggle-btn", panelId: "footer-panel" },
                ];

                configs.forEach(({ buttonId, panelId }) => {
                    const button = document.getElementById(buttonId);
                    const panel = document.getElementById(panelId);
                    const collapseBtn = panel.querySelector(".panel-collapse-btn");

                    panel.style.display = "none";
                    button.style.display = "flex";

                    button.addEventListener("click", (e) => {
                        e.stopPropagation();
                        panel.style.display = "";
                        button.style.display = "none";
                    });

                    collapseBtn.addEventListener("click", (e) => {
                        e.stopPropagation();
                        panel.style.display = "none";
                        button.style.display = "flex";
                    });
                });
            }
        </script>
    </body>
</html>
